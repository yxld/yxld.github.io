{"meta":{"title":"clam","subtitle":"Calm","description":"支撑一个人走完漫长一生的，是喜爱、擅长与心甘情愿","author":"yxld","url":"http://yxld.github.io","root":"/"},"pages":[],"posts":[{"title":"攻防世界—web（进阶区）","slug":"攻防世界——web（进阶区）","date":"2019-10-15T10:29:47.873Z","updated":"2019-10-15T10:30:41.849Z","comments":true,"path":"2019/10/15/攻防世界——web（进阶区）/","link":"","permalink":"http://yxld.github.io/2019/10/15/攻防世界——web（进阶区）/","excerpt":"","text":"前记瞅瞅进阶区的，继续总结。 1.NaNNaNNaNNaN-Batman打开题目并下载附件有乱码但看到&lt;script&gt;等标签的，后缀名改为html查看毫无头绪，查看wp发现整理下弹框内容发现直接将下面代码复制到控制台执行 123456789var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e&#125;&quot;];var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;];var r=[&quot;g&#123;&quot;,&quot;e&quot;,&quot;_0&quot;];var i=[&quot;it&apos;&quot;,&quot;_&quot;,&quot;n&quot;];var s=[t,n,r,i];for(var o=0;o&lt;13;++o)&#123; document.write(s[o%4][0]);s[o%4].splice(0,1)&#125; 得到flag 2.PHP2打开题目链接你可以浏览这个网站吗？No,I can’t.查看源码什么都没有，后面加上index.php。。。没用，加上index.phps（phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替）了解下urldecode()函数然后分析代码，get传入的id经过urldecode()函数解码，如果解码结果为admin，输出“Access granted!”和Key值(即flag)。经过两次urlencode()函数解码，所以 1payload：http://111.198.29.45:45494/index.php?id=a%2564min 得到flag 3.unserialize3题目提示unserialize即反序列化，PHP魔法函数中存在wakeup()方法，unserialize()会检查是否存在一个wakeup方法。如果存在，则会先调用 __wakeup方法，预先准备对象数据。于是构造1payload：O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125; 发现回显结果为：1bad requests 这里是因为wakeup()的影响，所以要绕过wakeup,当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行故构造 1payload：http://111.198.29.45:57697/?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125; 即可得出flag 后记ok,so much for today.","categories":[],"tags":[]},{"title":"攻防世界—web（练习区）","slug":"攻防世界—web（练习区）","date":"2019-09-25T10:24:45.751Z","updated":"2019-09-25T10:26:55.394Z","comments":true,"path":"2019/09/25/攻防世界—web（练习区）/","link":"","permalink":"http://yxld.github.io/2019/09/25/攻防世界—web（练习区）/","excerpt":"","text":"前记做题平台：攻防世界平台地址：https://adworld.xctf.org.cn/做题工具：Firefox web1.view_source拿到题目链接打开后发现右键不管用了于是乎在Firefox上打开web开发者中的web控制台，可获得flag web2.get_post在Firefox上打开插件hackbar，用get方式传递a=1勾选hackbar上的Enable Post data，用post方式传递b=2，可获得flag web3.robots打开题目链接一片空白百度了解下robots协议于是乎然后再一步获得flag web4.backup打开题目链接输入备份文件名下载并打开获得flag web5.cookie在Firefox上打开题目链接，以及web开发者工具，刷新后在存储一栏，可看到名为look-here的cookie的值为cookie.php访问http://111.198.29.45:47911/cookie.php，提示查看http响应包，在网络一栏，可看到访问cookie.php的数据包，获得flag web6.disabled_button在Firefox上打开题目连接，以及web开发者工具查看源码发现disabled标签（disabled 属性规定应该禁用 input 元素。被禁用的 input 元素既不可用，也不可点击）所以删掉就可以点击获得flag 7.simple_js打开题目链接就发现让输入密码随便输入个，查看源码发现无论输入什么都是错的，以及一串十六进制十六进制转十进制，然后对照asccii码表得到flag，注意格式就好 8.simple_php打开题目链接php中=== 会同时比较字符串的值和类型，== 会先将字符串换成相同类型，再作比较，比如1235A可以被判定为数字型。看php代码会发现同时满足 $a==0 和 $a 时，显示flag1。所以令 a=ad 或者a=adc都行同理令a=ab&amp;b=1235A，得flag2 后记Firefox及一些其他工具还是很方便的，再接再厉，基础题了解积累些基础知识。","categories":[],"tags":[]},{"title":"实验吧——密码学（二）","slug":"实验吧—密码学（二）","date":"2019-09-01T12:58:57.397Z","updated":"2019-09-01T13:02:15.206Z","comments":true,"path":"2019/09/01/实验吧—密码学（二）/","link":"","permalink":"http://yxld.github.io/2019/09/01/实验吧—密码学（二）/","excerpt":"","text":"1.变异凯撒拿到题目，对比格式和密文发现对应的前5个字符ASCII是有规律的，依次是97+5,102+6,90+7,95+8,114+9，按此规律将密文所有的ASCII码转换，就是答案： 2.传统知识+古典密码 从题目可以知道是 “干支数 + 甲子（60）”= 数字（ascii）对应的字母 辛卯，为干支之一，顺序为第28个 --&gt; 88 --&gt; X 癸巳，为干支之一，顺序为第30个 --&gt; 90 --&gt; Z 丙戌，为干支之一，顺序为第23个 --&gt; 93 --&gt; S 辛未，为干支之一，顺序为第8个 --&gt; 68 --&gt; D 庚辰，为干支之一，顺序为第17个 --&gt; 77 --&gt; M 癸酉，为干支之一,顺序为第10个 --&gt; 70 --&gt; F 己卯，为干支之一，顺序为第16个 --&gt; 76 --&gt; L 癸巳，为干支之一，顺序为第30个 --&gt; 90 --&gt; Z 古典密码，待解密字符串为： XZSDMFLZ。古典密码以换位、替换为主，试试常见的古典密码：换位栅栏、替换凯撒。这题是这两种组合，没有一点提示，很尴尬、、、首先，栅栏密码（两栏）解密：XMZFSLDZ，再用凯撒解密：SHUANGYU，加上格式即可。 3.疑惑的汉字评论提示有 当铺密码，了解一下直接提交数字发现不对，对应ascii码表试一下就出来了67 84 70 123 82 77 125C T F { R M } 4.NSCTF crypto50神秘的字符串真神秘，看提示有AES解密于是提交flag发现不对，继续凯撒解密根据题目发现flag是第17次解密，提交发现还是错误，估计是字母大小写有误，知道偏移量为16于是换个试试 5.最近在论证一个问题，到底是先有鸡还是先有蛋看到题目一脸懵，脑洞真大对应键盘加密，于是在那OOO了半天，才发现flaf是圈圈中间的字母、、、KEY 6.The Flash-14据了解The Flash是闪电侠的意思，闪电侠第二季第14集出现了一个5x5的加密方式…… 把26个英文字母排列成5x5的格式……但是5x5=25，另外一个跑哪去了？按照剧情里的介绍是C和K放在了一起然后这个解的方式是把这一串数分为2个一组，每组的第一个数代表纵坐标，第二个数代表横坐标，整理后可以得到：YSMWGTZOGVWGTNGHAOB 这个明显不是flag，那就凯撒移位试试人生处处是陷阱，去掉keyis然后fzstman明显是个错的、、、最后提交ctf{flashisfastman}即可。","categories":[],"tags":[]},{"title":"密码学——RSA算法","slug":"密码学—RSA算法","date":"2019-08-28T12:12:57.752Z","updated":"2019-08-29T03:41:58.998Z","comments":true,"path":"2019/08/28/密码学—RSA算法/","link":"","permalink":"http://yxld.github.io/2019/08/28/密码学—RSA算法/","excerpt":"","text":"一、对称加密and非对称加密对称加密是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。与公开密钥加密相比，要求双方取得相同的密钥是对称密钥加密的主要缺点之一。非对称加密，一种密码学算法类型，在这种密码学方法中，需要一对密钥(其实这里密钥说法不好，就是“钥”)，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。 二、RSA简介RSA算法是非对称加密算法，这种算法非常可靠，密钥越长，它就越难破解（本质上是对大数的质因数分解很难）。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。 三、相关数学概念1.素数素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。 如：2，3，5，7，11，13… 2.互素互质，又称互素。若N个整数的最大公因子是1，则称这N个整数互质。 3.欧拉函数欧拉函数 φ(n)是小于或等于n的正整数中与n互质的数的数目 如果n = 1, φ(1) = 1；(小于等于1的正整数中唯一和1互质的数就是1本身)； 如果n为质数，φ(n) = n - 1；因为质数和每一个比它小的数字都互质。比如5，比它小的正整数1,2,3,4都和他互质； 若m,n互质，则φ(mn) = φ(m)φ(n) 4.模运算模运算即求余运算。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余数，则二整数同余。两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。 5.模逆元（模反元素）一整数a对同余n之模逆元是指满足以下公式的整数b：ab ≡ 1 (mod n)整数 a 对模数 n 之模逆元存在的充分必要条件是 a 和 n 互素。 6.欧拉定理如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：a^φ(n) ≡ 1(mod n)根据这个定理以及模逆元的概念，可得a的φ(n)-1次方肯定是a关于n的模反元素。所以a关于n的模反元素必然存在。 比如，3和5互质，而5的欧拉函数φ(5)等于4，所以3的4次方*(81)减去1，可以被5整除（80/5=16）。 四、算法过程1.公钥与密钥的产生假设A想要通过一个不可靠的媒体接收B的一条私人讯息。她可以用以下的方式来产生一个公钥和一个私钥：获取N: 随意选择两个大的质数p和q，p不等于q，计算N=pq；获取r: 根据欧拉函数r = φ(N) = φ(p)φ(q) = (p-1)(q-1)；选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质，即求 e^(φ(r)-1) ）。(N,e)是公钥，(N,d)是私钥。A将她的公钥(N,e)传给B，私钥(N,d)自己保存。 2.加密消息假设B想给A送一个消息message，他知道A产生的公钥（N，e）。 于是B先将message转换为一个小于N的整数m。（如果是字符串可以取ascii值或unicode值；假如信息非常长，可以将分为几段，然后将每一段转换为m） 用下面这个公式他可以将m加密为c：m^e ≡ c (mod N)B算出c后就可以将它传递给A。 3.解密消息A得到B的消息c后就可以利用她的密钥（N, d）来解码。她可以用以下这个公式来将c转换为m：c^d ≡ m (mod N)得到m后，她就可以将原来的信息message重新复原。 4.安全性即使是在用户已经获取到公钥(N, e)的情况下，需要解开密文需要哪些步骤：如果想知道 d 需要知道欧拉函数 φ(n)的结果(即上文中提到的r = φ(N))；如果想知道欧拉函数 φ(n) 需要知道 p 和 q；要知道 p 和 q 需要对 N 进行质因数分解。 五、RSA相关练习题目提示RSA，求出私钥即可：φ(N)=φ( p )φ( q )=(p-1)(q-1)ed ≡ 1 (mod φ(N)) 所以ed=φ(N)+1，即17d=(p-1)(q-1)+1=473398607160*4511490+1 计算机拿出来，计算一下即可：","categories":[],"tags":[]},{"title":"SQLI-LABS（Basic Challenges 1-10）","slug":"SQLI-LABS（Basic Challenges上）","date":"2019-08-02T04:55:43.936Z","updated":"2019-09-25T10:27:25.710Z","comments":true,"path":"2019/08/02/SQLI-LABS（Basic Challenges上）/","link":"","permalink":"http://yxld.github.io/2019/08/02/SQLI-LABS（Basic Challenges上）/","excerpt":"","text":"最近学习一下sql注入，领教一下Sqli-labs的魅力。Sqli-labs下载 Less-1GET-Error based-Single quotes-String(基于错误的GET单引号字符型注入)打开界面：尝试?id=1:闭合符号一般是&#39;,&quot;,或无闭合符号或&#39;)，&quot;)；注释符号为--+。尝试?id=1&#39;:很明显单引号闭合，再?id=1&#39;--+注释掉后面的：接下来就要判断一下列数?id=1&#39; order by 4--+，发现一共三列，然后进行联合查询?id=0&#39; union select 1,2,3--+,这里将id等于一个数据库不存在的数，通过联合查询能看出我们输入的数据在哪里能够显示出来在2，3的位置我们便可插入我们想用的语句了，接下来要做的就是报数据表在此之前，我们要知道在MySQL中有information_schema这个库，该库存放了所有数据库的信息。information_schema.columns包含所有表的字段table_schema 数据库名table_name 表名column_name 列名information_schema.tables包含所有库的表名table_schema 数据库名table_name 表名information_schema.schemata包含所有数据库的名schema_name 数据库名group_concat()函数功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 ?id=0&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;security&apos;--+ 然后进行爆字段?id=0&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),3 --+接下来把用户名和密码全爆出来?id=0&#39; union select 1,group_concat(username,0x3a,password),3 from users --+（其中0x3a是用来区分用户名和密码，不至于混淆） Less-2GET-Error based-Intiger based（基于错误的GET整型注入）源代码发现根据Less-1可知，一共三列然后?id=0 union select 1,database(),user()就能得出当前数据库名和当前用户名 Less-3GET-Error based -Single quotes with twist-string（基于错误的GET单引号变形字符型注入）先尝试?id=1&#39;可以知道应该是单引号和括号的闭合?id=1&#39;)--+得 Less-4GET-Error based-Double Quotes-String（基于错误的GET双引号字符型注入）尝试?id=1&#39;发现没有报错，接着尝试一下?id=1&quot;发现发现是双引号和括号的闭合，于是?id=1&quot;)--+就可以了后面的步骤与Less-1一样就可以了。 Less-5GET-Double Injection-Single Quotes-String（双注入GET单引号字符型注入）尝试?id=1&#39;，出现可以判断出是单引号闭合。 Less-6GET-Double Injection-Double Quotes-String（双注入GET双引号字符型注入） 尝试?id=1&quot;，出现可以判断出是双引号闭合。 Less-7GET-Dump into outfile-String（导出文件GET字符型注入）尝试?id=1&#39;,出现报错继续尝试?id=1&#39;--+，发现没有用。于是换一种闭合方式试一下?id=1&#39; or &#39;1&#39;=&#39;1 Less-8GET-Blind-Boolian Based-Single Quotes（布尔型单引号GET盲注）尝试?id=1&#39;，发现没有报错，页面也没有返回东西，是bool盲注。盲注需要掌握一些MySQL的相关函数：length(str)：返回str字符串的长度。substr(str, pos, len)：将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始mid(str,pos,len):跟上面的一样，截取字符串ascii(str)：返回字符串str的最左面字符的ASCII代码值。ord(str):同上，返回ascii码if(a,b,c) :a为条件，a为true，返回b，否则返回c，如if(1&gt;2,1,0),返回0要记得常见的ASCII，A:65,Z:90 a:97,z:122, 0:48, 9:57首先select database()查询数据库ascii(substr((select database()),1,1))：返回数据库名称的第一个字母,转化为ascii码ascii(substr((select database()),1,1))&gt;64：ascii大于64就返回true，if就返回1，否则返回0构造语句?id=1&#39; and if(ascii(substr((select database()),1,1))&gt;64, 1, 0) #尝试一下 Less-9GET-Blind-Time based-Single Quotes（基于时间的GET单引号盲注）无论尝试什么，页面都没发生变化，是时间盲注。尝试?id=1&#39; and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(5))#，页面过了一会响应，判断闭合方式为单引号。 Less-10GET-Blind-Time based-double quotes（基于时间的双引号盲注）上一个题目中的单引号改为双引号即可。。。 小结上面的题型大概分4种1.联合查询注入2.报错注入3.bool盲注4.时间盲注每种题型也有自己独特的解法：1.对于联合查询注入，可以利用Union，直接select出你想要的信息2.对于报错注入，可以很快的找到引号闭合方式，使用特定的函数使其报错，得到信息3.对于bool盲注，没有回显，但是可以辨别出是ture还是fasle4.对于时间盲注，和bool盲注异曲同工，但是连回显都没有了，所以需要根据页面响应时间来判断是ture or false另：bool盲注以及时间盲注可以写脚本来解决，这个还需后期学习。","categories":[],"tags":[]},{"title":"实验吧——密码学（一）","slug":"实验吧—密码学（一）","date":"2019-07-14T10:36:09.937Z","updated":"2019-09-01T13:02:11.728Z","comments":true,"path":"2019/07/14/实验吧—密码学（一）/","link":"","permalink":"http://yxld.github.io/2019/07/14/实验吧—密码学（一）/","excerpt":"","text":"前记做题平台：实验吧平台网址：http://www.shiyanbar.com 围在栅栏中的爱先拿去摩斯密码解密得到根据 QWE到底等不等于ABC , 想到密码替换，于是题目也提示了有栏栅加密，就拿去跑栏栅再倒序一下就可以了 我喜欢培根打开题目连接是一串摩斯密码解密后得到MORSE..–.-IS..–.-COOL..–.-BUT..–.-BACON..–.-IS..–.-COOLER..–.-DCCDCCCDDDCDCCCDDCCCCCCCCCDDCDCCCCDCCCCC/CDCCCDCCDC/CCCDCCDDDCCDDDCCDCDD接下来就是培根密码，这里显示的是C和D，我们可以将C和D转换为ａ和b，这个时候我们只需要将所有的D替换成b，将所有的C替换成a就行了，然后就如下所示：baabaaabbbabaaabbaaaaaaaaabbabaaaabaaaaaabaaabaabaaaabaabbbaabbbaababb解密一下就出来了 困在栅栏里的凯撒先用栅栏得：NEQ{etlydsf}再用凯撒暴力得到：CTF{tianshu}","categories":[],"tags":[]},{"title":"BUGKU——MISC","slug":"BUGKU—MISC","date":"2019-07-11T13:52:22.840Z","updated":"2019-07-14T10:37:12.000Z","comments":true,"path":"2019/07/11/BUGKU—MISC/","link":"","permalink":"http://yxld.github.io/2019/07/11/BUGKU—MISC/","excerpt":"","text":"杂项一（签到题）签到题没什么好说的，关注公众号即可。 杂项二（这是一张单纯的图片）保存图片然后用winhex打开发现unicode编码转化，在线工具得到flag 杂项三（隐写）下载压缩包，打开有一张图片。winhex打开图片发现把高改成和宽一样，把A4改成F4，即可得到flag 杂项四（眼见非实）下载好文件，文件后缀名改为.zip格式，打开后发现里面有一个名字为眼见非实的文档，打不开，文档格式改为压缩包格式发现好多文件打开word下的document.xml发现 杂项五（啊哒）下载后解压发现是一张图片查看图片属性，发现一串字符将16进制转换成ASCII码的到sdnisc_2018将图片格式改为压缩包后发现加密记事本，输入之前的sdnisc_2018可得flag","categories":[],"tags":[]},{"title":"WEB——XSS注入","slug":"WEB—XSS注入","date":"2019-07-10T15:16:05.975Z","updated":"2019-07-14T10:37:22.423Z","comments":true,"path":"2019/07/10/WEB—XSS注入/","link":"","permalink":"http://yxld.github.io/2019/07/10/WEB—XSS注入/","excerpt":"","text":"前记XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。简述人们经常将跨站脚本攻击（Cross Site Scripting）缩写为CSS，但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。跨站脚本攻击（XSS），是目前最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。原理HTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，与之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。题目网址：http://test.xss.tv/ level1第一关就用最常用的攻击语句试试。payload: &lt;script&gt;alert(1)&lt;/script&gt; level2观察源代码，发现需要把前面的&lt;input&gt;标签给闭合掉。payload： &quot;&gt;&lt;script&gt;alert(/hacker/)&lt;/script&gt; level3观察页面源代码，是单引号，在前面加&#39;把value给闭合掉。payload: &apos; onmouseover=&apos;alert(1) level4这里是双引号，在前面输入&quot;，把value给闭合掉。payload: &quot; onmouseover=&quot;alert(1) level5试试script,再看页面源代码，script被过滤了，那就用标签构造攻击语句试试。payload: &quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;aa&lt;/a&gt;// level6发现href和script都被过滤了，在上题基础上换大写试试。payload: &quot;&gt;&lt;a Href=&quot;javascript:alert(1)&quot;&gt;aa&lt;/a&gt;// 然后点击aa标签即可。 level7用双写绕过，过滤掉其中的script，但是一旦过滤掉，前后又可以重新拼接起来，形成一个完整的语句。payload: &quot;&gt;&lt;sscriptcript&gt;alert(/hacker/)&lt;/sscriptcript&gt; level8下面有&lt;a&gt;标签，直接输入这个语句 javascript:alert(/hacker/) 但是script会被过滤，换一种方式表达script，采用HTML字符实体转换地址。payload: &amp;#x006a;&amp;#x0061;&amp;#x0076;&amp;#x0061;&amp;#x0073;&amp;#x0063;&amp;#x0072;&amp;#x0069;&amp;#x0070;&amp;#x0074;&amp;#x003a;&amp;#x0061;&amp;#x006c;&amp;#x0065;&amp;#x0072;&amp;#x0074;&amp;#x0028;&amp;#x0031;&amp;#x0029; level9又是友情链接，发现输入的语句并没有进入到 &lt;a&gt;标签中，这里应该对格式有一定要求，查看其他博客后发现需要添加http://,否则不合法。payload: &amp;#x006a;&amp;#x0061;&amp;#x0076;&amp;#x0061;&amp;#x0073;&amp;#x0063;&amp;#x0072;&amp;#x0069;&amp;#x0070;&amp;#x0074;&amp;#x003a;alert(&apos;http://&apos;) level10 查看页面源代码，发现t_sort就是注入点，那就开始注入吧，代码中有隐藏的参数设置,把hidden改为text。payload: &amp;t_sort=8888&quot; type=&quot;text&quot; onmouseover=&quot;alert(666)","categories":[],"tags":[]},{"title":"ISCC2019——MISC总结","slug":"ISCC2019—MISC总结","date":"2019-06-05T12:48:14.195Z","updated":"2019-06-05T12:50:38.938Z","comments":true,"path":"2019/06/05/ISCC2019—MISC总结/","link":"","permalink":"http://yxld.github.io/2019/06/05/ISCC2019—MISC总结/","excerpt":"","text":"ISCC2019已经结束了，虽然做不出来几道题，但是经过后来的学习觉得还是有必要总结一下的。 MISC1（隐藏的信息）这道题主要是进制转换后再转ascll码，然后base解码首先考虑到每个数字的大小，就发现都是八进制，然后转为十进制然后十进制转ascll码得看起来应该是base解码，不妨试一下OK，flag出来了…… MISC2（倒立屋）房屋为什么会倒立！是重力反转了吗？这道题主要用到的是LSB隐写，用stegsolve打开图片接下来就简单了，会用工具就行没错，flag又出来了，不过是倒立的呦（9102_cCsI） MISC3（Keyes’ secret）这道题主要是关于键盘的，需要仔细观察键盘的规律。首先找出FLAG位置键盘字母连起来对应另一个字母OK，这道题过程有那么一点点麻烦 MISC4（无法执行的exe）这道题主要是png图片头部格式有问题。咋一看还以为是base解码，不妨试一下然后发现PNG，用winhex打开，对比png文件格式，发现问题，修复它然后得到二维码一张，扫它得到ISCC_2019 MISC5（他们能在一起吗）这道题主要是数据隐藏下载附件得到png图片扫描得到base解码后然后url解码得到PASS{0K_I_L0V3_Y0u!}你以为这就结束了？不这才刚刚开始（因为flag并不正确……）图片格式改为压缩包格式发现输入之前解出来的括号里面的内容打开OK了，flag是他们没有在一起。","categories":[],"tags":[]},{"title":"php学习笔记（四）","slug":"php学习笔记（四）","date":"2019-04-29T08:45:26.876Z","updated":"2019-04-29T08:08:58.656Z","comments":true,"path":"2019/04/29/php学习笔记（四）/","link":"","permalink":"http://yxld.github.io/2019/04/29/php学习笔记（四）/","excerpt":"","text":"一.会话控制http是一个无状态的协议，此协议无法维护两个事务之间的联系。当一个用户请求一个页面后再请求另外一个页面时，http无法告诉我们这两个请求是来自同一个人。为了使得网站可以跟踪客户端与服务器之间的交互，保存和记忆每个用户的身份和信息，这样就产生了会话控制。 （一）cookie当用户访问服务器时，服务器可以设置和访问cookie的信息。cookie保存在客户端，通常是IE和Firefox浏览器的cookie临时文件夹中，可以手动删除。 1.向客户端电脑中设置cookiesetcookie (name,value,expire,path,domain,secure); name参数必需，名称；value参数必需，值；expire参数可选，有效期；path参数可选，服务器路径；domain参数可选，域名；secure参数可选，规定是否通过安全的HTTPS连接来传输cookie。 2.在服务器端上读取cookie的内容$_COOKIE 3.将多维数组应用于cookie中setcookie(&quot;member[name]&quot;,&apos;姓名&apos;); setcookie(&quot;member[email]&quot;,&apos;1234567890@qq.com&apos;); 4.删除Cookiesetcookie(&quot;member&quot;,&apos;&apos;,time()-1); 注：使用setcookie删除cookie的时候，需要与当初设置cookie的时候参数一致。 （二）sessionsession与cookie不同，是将用户参数留在服务器端。session从用户访问页面开始，到断开与网站连接为止，形成一个会话的生命周期。 1.开启sessionsession_start(); 注：这个函数没有参数，且返回值均为true。 二.MySQLMySQL是关系模型数据库管理系统，以稳定、可靠、快速、可信而成为世界上最受欢迎的数据库管理系统之一。无论是小型网站还是大型网站，都可以通过MySQL完成数据存储业务。 （一）.数据库基本概念数据库：信息存储的仓库，包括一系列的关系措施；表:一个数据库中可以有若干张表（形式上你可以看出我们日常生活中建立的表）；字段:表里面的信息会分若干个栏目来存，这些栏目呢，我们在数据库技术叫”字段”,栏目里面存的具体信息叫”字段值”；记录：一条信息我们叫一条记录。一个数据库管理系统中可以建立若干个数据库，每个数据库中又可以建立若干张表,每张表中可以有若干条记录。 （二）MySQL支持的数据类型数值类型、日期类型、字符串类型 （三）(My)SQL使用入门1.SQL语言简介SQL 是用于访问和处理数据库的标准的计算机语言。SQL指结构化查询语言，全称是 Structured Query Language。SQL 可以访问和处理数据库。SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。 2.SQL分类1)DDL(Data Definition Languages)语句数据定义语句，通过这类语言可以对数据库进行创建删除更改。2)DML(Data Manipulation Language)语句数据操纵语句，用于添加、删除、更新和查询数据库记录并检查数据完整性。3)DCL(Data Control Language)语句数据控制语句，通过此类语句可以对数据库的相关权限进行设置。 3.DDL语句对数据库内部的对象进行创建、删除、修改等操作的语言,DDL语句更多的是由数据库管理员(DBA)使用，开发人员一般很少使用。 show databases; //查看数据库列表 1)创建数据库 create database 数据库名; 选择要操作的数据库：USE 数据库; 对于要操作的数据库我们需要使用use来选择一下。查看数据库中所有的数据表show tables;2)删除数据库 drop database 数据库名称; 3)创建表(在哪个数据库里面创建表需要先使用use选择到那个要操作的数据库)创建表 create table 表名( 字段1名 字段1类型 列的约束条件, 字段2名 字段2类型 列的约束条件, ... ) 创建完表之后可以查看表的定义 desc 表名; 查看创建表的SQL语句 show create table 表名 \\G 另： \\G选项使得记录能够按照字段竖向排列，以便更好地显示内容较长的记录，\\G后面无需再加分号。4)删除表 drop table 表名; 5)修改表修改表的字段类型 alter table 表名 modify [column] 字段定义 [first|after 字段名]; 增加表字段 alter table 表名 add [column] 字段定义 [first|after 字段名]; 删除表字段 alter table 表名 drop [column] 字段名; 字段改名 alter table 表名 change [column] 旧的字段名 字段定义 [first|after 字段名]; 注：change与modify都可以修改表的定义，不同的是change后面需要接两次列名，不方便，但是优点是change可以修改字段名称修改字段排列排序前面介绍的字段增加和修改语法(add/change/modify)中，都有一个可选项first|after 字段名,这个选择可以用来修改。字段在表中的位置新增的字段默认是加载在表中最后位置，而change/modify 默认都不会改变字段的位置。 alter table t1 modify id2 tinyint first; alter table t1 modify id2 tinyint after id1; 注意：change/first|after 字段名 这些关键字都是属于MySQL在标准SQL上的扩展，在其他的数据库上不一定适用6)更改表名 alter table 表名 rename [to] 新的表名; 4.DML语句select * from 表名;//查询 1)插入记录insert into 表名(字段1,字段2,字段3,...,字段n) values(值1,值2,值3,...,值n);也可以不用指定字段名，但是values后面的顺序应该和字段的排序一致多条： insert into 表名(字段1,字段2,字段3,...,字段n) values (值1,值2,值3,...,值n), (值1,值2,值3,...,值n), (值1,值2,值3,...,值n) ; 2)更新记录更新一个表 update 表名 set 字段1=值1,字段2=值2,...字段n=值n [where 条件]; 更新多个表中数据 update 表1,表2,...表n set 表1.字段1=表达式1,表n.字段n=表达式n [where 条件]; 注：多表更新更多的用在根据一个表的字段来动态的更新另外一个表的字段3)删除记录删除单表中的数据 delete from 表名 [where 条件]; 删除多个表中的数据 delete 表1,表2,...表n from 表1,表2,...表n [where 条件]; 不管是单表还是多表，不加where条件将会把表中的所有记录删除，所以操作时一定要小心。4)查询记录 select 字段名|* from 表名; 查询不重复的记录 SELECT distinct field1,field2 FROM 表名; 只要field1,field2任何一个字段有不同就会被选择。一般使用distinct,只筛选一个字段。注：条件字段比较符号：=,&lt;,&gt;,&gt;=,&lt;=,!=等比较运算符多个条件之间可以使用or and等，where 后面接条件 select * from 表名 where 条件 排序和限制排序: //asc:由低到高，也是默认值 select * from employee order by salary asc; //desc:由高到底 select * from employee order by salary desc; //多个字段排序 select * from employee order by salary desc,id desc; 限制:在语句的最后面 加上limit 数字1,数字2 来进行查询数量的限制。limit 数字1,数字2 数字1代表从第几条记录开启取(是从0开始的)，数字2代表取几条！聚合 ①sum求和 select sum(字段名) from 表名; ②count记录总数 select count(*|字段名) from 表名; ③max最大值 select max(字段名) from 表名; ④min最小值 select min(字段名) from 表名; ⑤GROUP BY分类聚合 select department,sum(salary) from employee group by department; ⑥WITH ROLLUP分类聚合后的结果进行再汇总 select sum(salary) from employee group by department with rollup; ⑦HAVING 注意：having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤 ，应该尽可能的对记录进行先过滤！ select sum(salary) from employee group by department having sum(salary)&gt;1000; 在一起使用：select sum(id),max(id),min(id),count(*) from a1; 5)表连接需求：显示多个表中的字段的时候即可使用表连接连接分类内连接：选取两张表中相互匹配的记录外连接：不仅仅选取两张相互匹配的记录，并且会选出其他不匹配的记录外连接左连接概念：包含左边表中的所有记录(包括右表中没有和它匹配的记录) select ename,deptname from emp left join dept on emp.deptno=dept.deptno; 右连接概念：包含右边表中的所有记录(包括左表中没有和它匹配的记录)左连接和右连接是可以相互转换的。6）子查询需求：一个查询需要另外一个查询的结果参与的时候用于子查询的关键字:in语法：select * from employee where id in(select eid from employee_late);in 在..里面注意点 in后面的子语句必须只返回一个字段若查询结果唯一(只有一条)可以使用=代替innot in与in相反exists语法：select语句 where exists(select 语句);exists：后面那个子语句有没有查询出记录来，如果查询出记录来返回true,否则就是false，并且查询出来的记录的具体的值是NULL也是没有关系,也是返回true.not exits与exists相反select * from emp where deptno in(select deptno from dept); 若查询结果唯一可以使用=代替in select * from emp where deptno=(select deptno from dept limit 1); 7）记录联合我们常常会碰到需要将两个表或者多个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示这是就需要用到记录联合。多个select 语句用UNION或者UNION ALL隔开即可实现区别：前者会将多个查询结果合并后并且进行去除重复后返回后者：则直接合并并不去除重复联合的条件：查询的列个数要相等","categories":[],"tags":[]},{"title":"html+css+php+cookie+mysql制作一个简易的登陆网页","slug":"html+css+php+cookie+mysql制作一个简易的登陆网页","date":"2019-04-28T07:56:57.360Z","updated":"2019-04-28T08:37:28.616Z","comments":true,"path":"2019/04/28/html+css+php+cookie+mysql制作一个简易的登陆网页/","link":"","permalink":"http://yxld.github.io/2019/04/28/html+css+php+cookie+mysql制作一个简易的登陆网页/","excerpt":"","text":"一味的学习未免有些枯燥无味，偶尔有个任务检验一下学习成果还是很有必要的 一.环境准备一切开始的基本 1.打开phpstudy 2.找到网站根目录，把文件放在WWW文件下这里我新建了一个login文件夹来存放，其中包括以下几个文件：login.php 登录页面register.php 注册页面loginout.php 注销页面index.php 登录成功页面skip.php 注销跳转页面 二.登录页面下面是登录界面的代码:php部分代码 &lt;?php if(isset($_POST[&apos;submit&apos;])) { if(isset($_POST[&apos;name&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;]) &amp;&amp; $_POST[&apos;name&apos;]!=NULL &amp;&amp; $_POST[&apos;password&apos;]!=NULL) { $link=mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;yxld&apos;);//连接数据库 if(mysqli_connect_errno()) { exit(mysqli_connect_errno()); } mysqli_select_db($link,&apos;login&apos;); $query=&quot;select * from t2 &quot;;//选择表 $result=mysqli_query($link,$query); $a=0; while($colum=mysqli_fetch_array($result)) { if($colum[&apos;name&apos;]===$_POST[&apos;name&apos;] &amp;&amp; $colum[&apos;password&apos;]===$_POST[&apos;password&apos;]) { $a++; break; } } if($a&gt;0) { if(setcookie(&apos;name&apos;,$colum[&apos;name&apos;],time()+600)) { header(&apos;Location:index.php&apos;); } } else { echo &quot;账号或密码错误，或者没有注册&quot;; } } else { echo &quot;账号或密码错误，或者没有注册&quot;; } } ?&gt; html+css部分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;title&gt;请登录&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;/*body&#123; background-image:url(jpg/4.jpg); background-repeat:no-repeat;&#125;*/#head&#123; margin-top:200px; text-align: center; font-family:&quot;楷体&quot;;/*设置字体*/ font-size:50px;/*设置字体大小*/ font-weight:2px;/*调整字体粗细*/ line-height: 35px; &#125;.s&#123; text-align: center; font-family:&quot;楷体&quot;;/*设置字体*/ font-size:15px;/*设置字体大小*/ &#125;.c&#123; margin-left:0%; border-radius:30px;&#125;#longin&#123; margin-left:46%; width: 160px; height: 25px; background-color:pink; border-radius:30px;&#125; #then&#123;margin-left:46%;&#125;a&#123; margin-left:2%;&#125;&lt;/style&gt;&lt;/head&gt; &lt;boby&gt; &lt;form method=&quot;post&quot; action=&quot;login.php&quot;&gt; &lt;p id=&quot;head&quot;&gt;用户登陆&lt;/p&gt; &lt;p class=&quot;s&quot;&gt;账号：&lt;input type=&quot;text&quot; name=&quot;name&quot; class=&quot;c&quot; /&gt;&lt;/p&gt; &lt;p class=&quot;s&quot;&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;c&quot; /&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot; id=&quot;longin&quot; name=&quot;submit&quot; /&gt; &lt;/br&gt; &lt;p id=&quot;then&quot;&gt;没有账号？&lt;a href=&quot;register.php&quot;&gt;前往注册&lt;/a&gt; &lt;/p&gt; &lt;/form&gt;&lt;/boby&gt;&lt;/html&gt; 三.注册页面注册界面的代码如下： 1234567891011121314151617181920212223242526272829&lt;?phpheader(&apos;Content-type:text/html;charset=utf-8&apos;);$link=mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;yxld&apos;); if(mysqli_connect_errno()) &#123; exit(mysqli_connect_errno()); &#125; mysqli_select_db($link,&apos;login&apos;); $query=&quot;select * from t2 &quot;; $result=mysqli_query($link,$query); $a=0; while($colum=mysqli_fetch_array($result)) &#123; if(@($colum[&apos;name&apos;]===$_COOKIE[&apos;name&apos;])) &#123; $a++; break; &#125; &#125;if(isset($_COOKIE[&apos;name&apos;])&amp;&amp;$a&gt;0)&#123; echo&quot;亲爱的&#123;$_COOKIE[&apos;name&apos;]&#125;您好，恭喜登陆成功！&quot;; echo&quot;&lt;a href=&apos;logout.php&apos;&gt;注销&lt;/a&gt;&quot;;&#125;else&#123; echo&quot;&lt;a href=&apos;login.php&apos;&gt;请前往登录&lt;/a&gt;&quot;;&#125;?&gt; 四.注册成功页面注册成功后跳转到登录页面进行登录。 五.登陆成功页面另：明明为用户名登录成功代码如下： 1234567891011121314151617181920212223242526272829&lt;?phpheader(&apos;Content-type:text/html;charset=utf-8&apos;);$link=mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;yxld&apos;); if(mysqli_connect_errno()) &#123; exit(mysqli_connect_errno()); &#125; mysqli_select_db($link,&apos;login&apos;); $query=&quot;select * from t2 &quot;; $result=mysqli_query($link,$query); $a=0; while($colum=mysqli_fetch_array($result)) &#123; if(@($colum[&apos;name&apos;]===$_COOKIE[&apos;name&apos;])) &#123; $a++; break; &#125; &#125;if(isset($_COOKIE[&apos;name&apos;])&amp;&amp;$a&gt;0)&#123; echo&quot;亲爱的&#123;$_COOKIE[&apos;name&apos;]&#125;您好，恭喜登陆成功！&quot;; echo&quot;&lt;a href=&apos;logout.php&apos;&gt;注销&lt;/a&gt;&quot;;&#125;else&#123; echo&quot;&lt;a href=&apos;login.php&apos;&gt;请前往登录&lt;/a&gt;&quot;;&#125;?&gt; 六.注销及其跳转页面登陆成功后点击注销，将进行跳转，其代码如下： 1234567891011121314151617&lt;?phpif(!isset($_GET[&apos;url&apos;])||!isset($_GET[&apos;info&apos;]))&#123; exit();&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;URL=&lt;?php echo $_GET[&apos;url&apos;]?&gt;&quot;/&gt;&lt;title&gt;正在跳转中...&lt;/title&gt;&lt;/head&gt;&lt;boby&gt; &lt;div style=&quot;text-align:center;font-size:20px;&quot;&gt;&lt;?php echo $_GET[&apos;info&apos;]?&gt;,3秒后自动跳转！&lt;/div&gt;&lt;/boby&gt;&lt;/html&gt; 跳转后就是注销后的界面注销成功就前往登录界面，注销代码如下： 1234567891011121314&lt;?phpheader(&apos;Content-type:text/html;charset=utf-8&apos;);if(isset($_COOKIE[&apos;name&apos;]))&#123; if(setcookie(&apos;name&apos;,$_COOKIE[&apos;name&apos;],time()-600)) &#123; header(&apos;Location:skip.php?url=index.php&amp;info=注销成功，正在跳转中！&apos;); &#125; else &#123; header(&apos;Location:skip.php?url=index.php&amp;info=注销失败，请稍后重试！&apos;); &#125;&#125;?&gt; 通过此次任务，我也学到了很多，比如数据库的连接、cookie会话控制等。虽然任务进程缓慢，完成任务不够及时，但是我也发现了自己学习的一些缺点，比如知识记得不够牢固，一些知识点不会运用等，所以以后需要在学习之后好好练习一番。","categories":[],"tags":[]},{"title":"php学习笔记（三）","slug":"php学习笔记（三）","date":"2019-04-21T12:34:46.419Z","updated":"2019-04-28T08:33:31.160Z","comments":true,"path":"2019/04/21/php学习笔记（三）/","link":"","permalink":"http://yxld.github.io/2019/04/21/php学习笔记（三）/","excerpt":"","text":"一.正则表达式1.理解正则表达式语法规则描述了一类字符串的特征，然后通过这个特征可以配合一些特定的函数，来完成对字符串更加复杂的一系列操作。正则表达式：普通字符和特殊字符组成的一个字符串。定界符一般习惯使用正斜线/作为定界的字符,前后一致普通字符比如：a-z，A-Z，0-9，双引号，单引号它们没有特殊的含义。 2.元字符元字符指的是在正则表达式中有特殊含义的字符。 \\d //匹配任意一个十进制数字，等价于[0-9] \\D //匹配任意一个除十进制数字以外字符,等价于[^0-9] \\s //匹配任意一个空白字符,比如换页符、换行符、回车符、制表符、垂直制表符 \\S //匹配除空白字符以外的任何一个字符 \\w //匹配任意一个数字或字母或下划线 \\W //匹配除数字、字母、下划线以外的任意一个字符 . //匹配除换行符以外的任意一个字符 * //匹配0次、或1次、或多次其前面的字符 + //匹配1次或多次其前面的字符 ? //匹配0次或1次其前面的字符 {n} //表示其前面字符恰好出现n次 {n,} //表示其前面字符出现不少于n次 {n,m} //表示其前面的字符至少出现n次，最多出现m次 ^或\\A //匹配字符串开始位置 $或者\\Z //匹配字符串的结束位置 | //匹配两个或多个模式 [] //匹配方括号中的任意一个字符 [^] //匹配除方括号中字符以外的任意一个字符 () //将括号中作为一个整体以便将其中的内容获取到,在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可以使用\\\\数字 来代表圆括号部分所匹配到的内容！ 3.模式修正符模式修正符是在正则表达式的定界符之后使用的，可以调整正则表达式的解释，扩展正则表达式在匹配换等操作是的某些功能，增强正则表达式的处理能力。常见模式修正符 i //在和模式进行匹配时不区分大小写 m //多行匹配，如果目标字符串 中没有&quot;\\n&quot;字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响 s //如果设定了此修正符，那么.将匹配所有的字符包括换行符 U //禁止贪婪匹配 4.与正则表达式配合的函数 preg_match() 执行一个正则表达式匹配 preg_match_all() 执行一个全局正则表达式匹配 preg_replace 执行一个正则表达式的搜索和替换 二.日期与时间设置时区 date_default_timezone_set(&apos;Asia/Shanghai&apos;);//设置时区 获取当前Unix时间戳 time() 获取指定时间的Unix时间戳 mktime() date_default_timezone_set(&apos;Asia/Shanghai&apos;);//设置时区 $nowTime=time(); $time1=mktime(0,0,0,10,1,2019);//取得一个日期的 Unix 时间戳 echo &apos;距离2019年国庆还有&apos;.(($time1-$nowTime)/60/60/24).&apos;天&apos;; 从Unix时间戳取得时间日期信息 date()//格式化一个本地时间／日期,第一个参数:必填,写上你所需要的时间日期的格式,把format 字符放在第一个参数里面会被转换成对应的信息,其他的字符还是原来的样子 date(&apos;Y-m-d G:i:s&apos;)//自定义格式化Unix时间戳 为指定的时间格式! 获取Unix时间戳和微秒数 microtime() //返回当前 Unix 时间戳和微秒数 三.图像处理1.创建图像的基本步骤创建图像所有的绘图设计都需要在一个图像上完成，以后的操作都将基于这个图像。 $img=imagecreatetruecolor(200,200);//新建一个长和高都为200像素的真彩色图像 绘制图像图像创建完成后，就可以通过这个图像资源，使用各种图像函数设置图像的颜色、填充画布、画点、线段、各种几何图形以及向图像添加文本等。 $color=imagecolorallocate($img,50,50,50);//分配颜色 imagefill($img,0,0,$color);//区域填充 输出图像header()函数： header(&apos;Content-type:image/jpeg&apos;);//默认情况header(&apos;Content-type:text/html&apos;); 在该函数之前，不能输出任何内容。在我们的PHP代码 的函数里面，我们使用的/开头的路径，这个/不是指 web根目录,而是操作系统的文件的根目录。 imagejpeg($img);//以JPEG格式将图像输出到浏览器或文件 释放资源 imagedestroy($img);//销毁一图像 2.验证码&lt;?php header(&apos;Content-type:image/jpeg&apos;); $width=120; $height=40; $element=array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;,&apos;j&apos;,&apos;k&apos;,&apos;m&apos;,&apos;n&apos;,&apos;o&apos;,&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;,&apos;t&apos;,&apos;u&apos;,&apos;v&apos;,&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;); $string=&apos;&apos;; for ($i=0;$i&lt;5;$i++){ $string.=$element[rand(0,count($element)-1)]; } $img=imagecreatetruecolor($width, $height);//新建一个真彩色图像 $colorBg=imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));//为一幅图像分配颜色 $colorBorder=imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));//为一幅图像分配颜色 $colorString=imagecolorallocate($img,rand(10,100),rand(10,100),rand(10,100));//为一幅图像分配颜色 imagefill($img,0,0,$colorBg);//区域填充 imagerectangle($img,0,0,$width-1,$height-1,$colorBorder);//画一个矩形 for($i=0;$i&lt;100;$i++){ imagesetpixel($img,rand(0,$width-1),rand(0,$height-1),imagecolorallocate($img,rand(100,200),rand(100,200),rand(100,200)));//画一个单一像素 } for($i=0;$i&lt;3;$i++){ imageline($img,rand(0,$width/2),rand(0,$height),rand($width/2,$width),rand(0,$height),imagecolorallocate($img,rand(100,200),rand(100,200),rand(100,200)));//画一条线段 } //imagestring($img,5,0,0,&apos;abcd&apos;,$colorString);//水平地画一行字符串 imagettftext($img,14,rand(-5,5),rand(5,15),rand(30,35),$colorString,&apos;字体路径&apos;,$string);//用 TrueType 字体向图像写入文本 imagejpeg($img);//以JPEG格式将图像输出到浏览器或文件 imagedestroy($img);//销毁一图像 ?&gt; 3.水印&lt;?php header(&apos;Content-type:image/jpeg&apos;); $img=imagecreatefromjpeg(&apos;images/zcx.jpg&apos;);//由文件或 URL 创建一个新图象 $waterMark=imagecreatefromgif(&apos;路径&apos;);//由文件或 URL 创建一个新图象 $color=imagecolorallocate($img,255,255,255);//为一幅图像分配颜色 $width=imagesx($img);//取得图像宽度 $height=imagesy($img);//取得图像高度 $waterMarkWidth=imagesx($waterMark); $waterMarkHeight=imagesy($waterMark); $position=imagettfbbox(20,0,&apos;字体路径&apos;,&apos;水印&apos;);//给出一个使用 FreeType 2 字体的文本框 $stringWidth=$position[2]-$position[0]; //文字水印 //imagettftext($img,20,0,$width-1-$stringWidth-($width/30),$height-1-($height/30), $color,&apos;font/china1.TTF&apos;,&apos;水印&apos;);//使用 FreeType 2 字体将文本写入图像 /* imagecopymerge($img,$waterMark,100,100,0,0,$waterMarkWidth,$waterMarkHeight,0);//拷贝并合并图像的一部分 参数说明： $img:目标图像资源 $waterMark:水印的图像资源 100:所要拷贝到目标图像资源上面的坐标(x轴位置) 100:所要拷贝到目标图像资源上面的坐标(y轴位置) 0:从水印的图像资源的x坐标为0的位置开始拷贝 0:从水印的图像资源的y坐标为0的位置开始拷贝 $waterMarkWidth:所要拷贝的水印图像的长度 $waterMarkHeight:所要拷贝的水印图像的高度 0:表示透明度,数值越小就越透明，最大值100相当于和imagecopy这个函数一样 */ imagecopymerge($img,$waterMark,$width-1-$waterMarkWidth,$height-1-$waterMarkHeight,0,0,$waterMarkWidth,$waterMarkHeight,30);//拷贝并合并图像的一部分 imagejpeg($img);//以JPEG格式将图像输出到浏览器或文件 imagedestroy($img);//销毁图像 ?&gt; 4.缩放与裁剪&lt;?php /* 等比例缩放 */ header(&apos;Content-type:image/jpeg&apos;); $width=300; $img=imagecreatefromjpeg(&apos;路径&apos;); //由文件或 URL 创建一个新图象 $imgWidth=imagesx($img); $imgHeight=imagesy($img); $height=$width/($imgWidth/$imgHeight); $img1=imagecreatetruecolor($width,$height); /* imagecopyresampled($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h)//重采样拷贝部分图像并调整大小 参数说明： $dst_image:目标图像资源 $src_image:源图像资源（你要采样的那个图像资源） $dst_x: $dst_y:与上面的$dst_x确定了一个坐标,把采样到的部分 放到目标图像资源的什么位置 $src_x: $src_y:与上面的$src_y确定了一个坐标,你要采样的原图像资源的 某个部分的起始坐标 $dst_w: $dst_h:与上面的$dst_w确定了 放到目标图像资源上面的尺寸 $src_w: $src_h:与上面的$src_w确定了 采样原图像资源的 某个部分 */ imagecopyresampled($img1,$img,0,0,0,0,$width,$height,$imgWidth,$imgHeight); //裁剪 //imagecopyresampled($img1,$img,0,0,0,0,100,100,100,100); if(imagejpeg($img1)){ imagejpeg($img1,路径&apos;); } imagedestroy($img); imagedestroy($img1); ?&gt; 另：更多图像处理相关函数 四.文件与目录操作判断普通文件和目录 is_file()//判断给定文件名是否为一个正常的文件 is_dir()//判断给定文件名是否是一个目录 文件的属性 file_exists()//检查文件或目录是否存在 filesize()//取得普通文件大小 is_readable()//判断给定文件名是否可读 is_writable()//判断给定的文件名是否可写 filectime()//获取文件的创建时间 filemtime()//获取文件的修改时间 fileatime()//取得文件的上次访问时间 stat()//获取文件大部分属性值 1.目录的基本操作1.basename()//返回路径中的文件名部分 2.dirname()//返回路径中的目录部分 3.pathinfo()//返回文件路径的信息 4.opendir()//打开目录句柄 5.readdir()//从目录句柄中读取条目,返回目录中下一个文件的文件名 6.rewinddir()//倒回目录句柄 7.closedir()//关闭目录句柄 8.mkdir()//新建目录 9.rmdir()//删除指定的空目录 10.scandir()//列出指定路径中的文件和目录 2.文件的基本操作1.fopen()//打开文件或者 URL 2.fread()//读取文件 3.fgets()//从文件指针中读取一行 4.feof()//测试文件指针是否到了文件结束的位置 5.fwrite()//写入文件 6.rewind()//倒回文件指针的位置 7.flock()//轻便的咨询文件锁定 8.ftruncate()//将文件截断到给定的长度 9.fclose()//关闭一个已打开的文件指针 10.file() //把整个文件读入一个数组中 11.copy()//拷贝文件 12.unlink()//删除文件 13.file_get_contents()//将整个文件读入一个字符串 14.file_put_contents()//将字符串写入文件中 15.rename()//重命名一个文件或目录 16.readfile()//读入一个文件并写入到输出缓冲 3.文件上传文件的上传的过程这些细节我们是不需要管的，都是自动的，上传的文件默认是放在一个临时的目录里面的，我们要做的就是把这些临时目录里面的文件移动到我们需要的地方就可以了。 4.文件下载&lt;?php if(!function_exists(&apos;finfo_open&apos;)){ header(&apos;Content-type:text/html;charset=utf-8&apos;); exit(&apos;请先开启PHP扩展:fileinfo！&apos;); } $file=&apos;a.rar&apos;; $fileinfo=finfo_open(FILEINFO_MIME_TYPE); $mimeType=finfo_file($fileinfo,$file); finfo_close($fileinfo); //发送指定的文件MIME类型的头信息 header(&apos;Content-type:&apos;.$mimeType); //指定下载文件的描述 header(&apos;Content-Disposition:attachment;filename=&apos;.basename($file)); //指定文件的大小 header(&apos;Content-Length:&apos;.filesize($file)); //读取文件内容至输出缓冲区,返回这个文件 readfile($file); ?&gt;","categories":[],"tags":[]},{"title":"php学习笔记（二）","slug":"php学习笔记（二）","date":"2019-04-17T02:48:30.969Z","updated":"2019-04-28T08:47:22.527Z","comments":true,"path":"2019/04/17/php学习笔记（二）/","link":"","permalink":"http://yxld.github.io/2019/04/17/php学习笔记（二）/","excerpt":"","text":"一.函数函数（function）是一段完成特定功能的已命名代码块。函数可以遵照参数完成特定的任务，并且可能返回一个值。 1.自定义函数函数的定义function 函数名称（参数1 ,参数2=默认值 ,…）{ 程序内容叙述(也叫函数体)； return 返回值; //return语句将终止函数的执行 } 另：函数的名称应该体现出它的功能，函数名可以是以字母或下划线开头后跟字母、下划线和数字。 函数的调用函数只有在被调用时才会执行，函数被调用后开始执行函数体中代码，执行的过程是相对独立的，执行完后返回调用的位置继续向下执行。 函数的参数 函数可以有零个或多个参数 函数的参数可以为任意数据类型 函数的参数往往用来改变函数执行结果或执行行为 函数的返回值 return语句并不是必须的 默认情况下，函数的返回值为NULL return语句将终止函数的执行 2.变量范围局部变量局部变量是在函数内定义的，它的作用域仅限于函数内部。 全局变量全局变量是在函数外定义的，它的作用域为从变量定义处开始到本程序的末尾。在php函数中无法直接使用全局变量，如果使用必须使用global声明变量。 静态变量静态变量是指在函数内部定义变量的时候使用static关键字来定义变量。 3.参数传递在函数的形参中使用“&amp;“修饰的参数在调用该函数时必须传入一个变量给这个参数，而不能传递一个具体的值。 $i=100; function test($a) { echo ++$a; } test($i); echo $i; 4.可变函数以一个变量的值作为函数名的函数 function test() { } $a=&apos;test&apos;; $a(); 5.递归函数函数直接或间接调用函数本身，则该函数称为递归函数。必须具备判断是否执行递归调用的条件。终止函数的递归调用时，需把目前流程的主控权交回上一层函数执行。函数递归调用最大的好处在于可以精简程序中繁杂重复调用程序。 function fun($n){ echo $n.&apos;&amp;nbsp;&apos;; if($n&gt;0){ fun($n-1); }else{ echo &apos;&lt;br/&gt;&apos;; } echo $n.&apos;&amp;nbsp; &apos; ; } fun(3); 6.内部函数php有很多提供给我们现成的函数或结构。比如： echo() include() include_once() require() 二.数组1.理解与创建理解数组是php中的重要数组类型之一，是复合类型;数据的集合，在php中数组是一个有序映射. 创建法一： 变量名称[索引值]=数据； 变量名称[]=数据；//不写索引值默认是索引数组，从零开始 法二： 变量名称=array( 索引值=&gt;数据， ........ )； 2.遍历数组for循环用的比较少，因为有缺陷。通过foreach遍历数组 foreach($数组名称 as $变量名称){循环体;}; foreach($数组名称 as 变量1=&gt;变量2){循环体;}； 3.预定义超全局数组预定义：已经定义好的变量（存放的数据的类型是数组）。 超全局：超级全局变量，作用域（有效区域）。 传递数据（提交数据）给服务器端主要两种方式： get方式 ?参数名=参数值&amp;参数名=参数值…… 在服务器端（请求的php文件这边）可以通过$_GET来获取到post方式比如表单post发送过来的一般用$_POST来获取 4.处理数组的相关函数相关函数我们可以通过查手册来使用：数组的相关函数 三.字符串处理1.去除空白或其他字符函数 trim(） trim($字符串名称,&quot;char&quot;); char为你要去除的字符，如果省略，就是去除首尾的空白 ltrim()去除字符串左边的字符或空白 rtrim()去除字符串右边的字符或空白 2.大小写转换函数strtoupper()将字符串转化为大写 strtoupper($字符串名称); strtolower()将字符串转化为小写 strtolower($字符串名称); 3.字符串查找函数substr_count()计算字串出现的次数 substr_count($字符串,$needle); substr_count($字符串,$needle,$offset,$length) /* needle(char)：要查找的字符或字符串 offset(int)：从第第几位开始查找（从0开始数） length(int)：从开始查找的位置开始向后查多少位 该函数返回的是整型 */ strpos()查找字符串首次出现的位置 strpos($字符串名称,$needle) strpos($字符串名称,$needle,$offset) /* needle(char)：要查找的字符或字符串 offset(int)：从第第几位开始查找（从0开始数） 该函数返回的值可能是整型，也可能是布尔类型的false（当返回的值为0时） */ strstr()查找字符串的首次出现 strstr($字符串名称,$needle) strstr($字符串名称,$needle,before_needle) /* needle(char)：要查找的字符或字符串 该函数返回字符串，该字符串为needle(char)及其后面的内容 before_needle：如果为true,则返回needle(char)之前的内容（不包括needle(char)） */ 4.字符串替换函数str_replace()子字符串替换 str_replace($search,$replace,$str) str_replace($search,$replace,$str,$count) /* search(char)：要替换的字符 replace(char)：要替换成的字符 count(int)：替换的次数 也可以用数组一次替换多个字符 str_replace(array(&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;),array(&apos;d1&apos;,&apos;d2&apos;,&apos;d3&apos;),$str) str字符串中的c1,c2,c3会被替换成d1,d2,d3 该函数返回字符串 */ 5.与html标签相关的函数htmlspecialchars()//将特殊字符转换为html 实体strip_tags()//从字符串中去除 html和 php 标记 6.字符串截取函数substr()返回字符串的子串 substr($str,$start) substr($str,$start,$length) /* str：传入的字符串 start(int)：从此处开始截取（从0开始数），若为负数则从尾开始数 length(int)：返回的字符串的长度 */ 7.字符串分隔函数explode()使用一个字符串分割另一个字符串 explode($delimiter,$字符串名称) explode($delimiter,$字符串名称,$limit) /* delimiter(char)：从此字符处分割 limit(int)：限制分割的次数，分割limit-1次 */ str_split()将字符串转换为数组 str_split($字符串名称,$split_length) /* split_length：每个转换成的数组中的元素有多少个字符 返回一个数组 */ 字符串处理手册","categories":[],"tags":[]},{"title":"数据结构之哈夫曼树","slug":"数据结构之哈夫曼树","date":"2019-04-14T12:27:40.484Z","updated":"2019-04-28T08:36:42.247Z","comments":true,"path":"2019/04/14/数据结构之哈夫曼树/","link":"","permalink":"http://yxld.github.io/2019/04/14/数据结构之哈夫曼树/","excerpt":"","text":"一.简介给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1L1+W2L2+W3L3+…+WnLn），N个权值Wi（i=1,2,…n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,…n）。可以证明霍夫曼树的WPL是最小的。 二.基本术语1.路径和路径长度在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 2.结点的权及带权路径长度若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 3.树的带权路径长度树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。 三.构造假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；(3)从森林中删除选取的两棵树，并将新树加入森林；(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。图解过程： 四.编码利用哈夫曼树求得的二进制编码称为哈夫曼编码。树中从根到每个叶子节点都有一条路径，对路径上的各分支约定指向左子树的分支表示”0”码，指向右子树的分支表示“1”码，取每条路径上的“0”或“1”的序列作为各个叶子节点对应的字符编码，即是哈夫曼编码。 就拿上图例子来说： A，B，C，D对应的哈夫曼编码分别为：111，10，110，0 用图说明如下： 五.例题及代码实现例：C++实现： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef int ELEMTYPE; // 哈夫曼树结点结构体 typedef struct HuffmanTree { ELEMTYPE weight; ELEMTYPE id; // id用来主要用以区分权值相同的结点，这里代表了下标 struct HuffmanTree* lchild; struct HuffmanTree* rchild; }HuffmanNode; // 构建哈夫曼树 HuffmanNode* createHuffmanTree(int* a, int n) { int i, j; HuffmanNode **temp, *hufmTree; temp = malloc(n*sizeof(HuffmanNode)); for (i = 0; i&lt;n; ++i) // 将数组a中的权值赋给结点中的weight { temp[i] = (HuffmanNode*)malloc(sizeof(HuffmanNode)); temp[i]-&gt;weight = a[i]; temp[i]-&gt;id = i; temp[i]-&gt;lchild = temp[i]-&gt;rchild = NULL; } for (i = 0; i&lt;n - 1; ++i) // 构建哈夫曼树需要n-1合并 { int small1 = -1, small2; // small1、small2分别作为最小和次小权值的下标 for (j = 0; j&lt;n; ++j) // 先将最小的两个下标赋给small1、small2（注意：对应权值未必最小） { if (temp[j] != NULL &amp;&amp; small1 == -1) { small1 = j; continue; } else if (temp[j] != NULL) { small2 = j; break; } } for (j = small2; j&lt;n; ++j) // 比较权值，挪动small1和small2使之分别成为最小和次小权值的下标 { if (temp[j] != NULL) { if (temp[j]-&gt;weight &lt; temp[small1]-&gt;weight) { small2 = small1; small1 = j; } else if (temp[j]-&gt;weight &lt; temp[small2]-&gt;weight) { small2 = j; } } } hufmTree = (HuffmanNode*)malloc(sizeof(HuffmanNode)); hufmTree-&gt;weight = temp[small1]-&gt;weight + temp[small2]-&gt;weight; hufmTree-&gt;lchild = temp[small1]; hufmTree-&gt;rchild = temp[small2]; temp[small1] = hufmTree; temp[small2] = NULL; } free(temp); return hufmTree; } // 以广义表的形式打印哈夫曼树 void PrintHuffmanTree(HuffmanNode* hufmTree) { if (hufmTree) { printf(&quot;%d&quot;, hufmTree-&gt;weight); if (hufmTree-&gt;lchild != NULL || hufmTree-&gt;rchild != NULL) { printf(&quot;(&quot;); PrintHuffmanTree(hufmTree-&gt;lchild); printf(&quot;,&quot;); PrintHuffmanTree(hufmTree-&gt;rchild); printf(&quot;)&quot;); } } } // 递归进行哈夫曼编码 void HuffmanCode(HuffmanNode* hufmTree, int depth) // depth是哈夫曼树的深度 { static int code[100]; if (hufmTree) { if (hufmTree-&gt;lchild == NULL &amp;&amp; hufmTree-&gt;rchild == NULL) { printf(&quot;id为%d权值为%d的叶子结点的哈夫曼编码为 &quot;, hufmTree-&gt;id, hufmTree-&gt;weight); int i; for (i = 0; i&lt;depth; ++i) { printf(&quot;%d&quot;, code[i]); } printf(&quot;\\n&quot;); } else { code[depth] = 0; HuffmanCode(hufmTree-&gt;lchild, depth + 1); code[depth] = 1; HuffmanCode(hufmTree-&gt;rchild, depth + 1); } } } // 哈夫曼解码 void HuffmanDecode(char ch[], HuffmanNode* hufmTree, char string[]) // ch是要解码的01串，string是结点对应的字符 { int i; int num[500]; HuffmanNode* tempTree = NULL; for (i = 0; i&lt;strlen(ch); ++i) { if (ch[i] == &apos;0&apos;) num[i] = 0; else num[i] = 1; } if (hufmTree) { i = 0; // 计数已解码01串的长度 while (i&lt;strlen(ch)) { tempTree = hufmTree; while (tempTree-&gt;lchild != NULL &amp;&amp; tempTree-&gt;rchild != NULL) { if (num[i] == 0) { tempTree = tempTree-&gt;lchild; } else { tempTree = tempTree-&gt;rchild; } ++i; } printf(&quot;%c&quot;, string[tempTree-&gt;id]); // 输出解码后对应结点的字符 } } } int main() { int i, n; printf(&quot;请输入叶子结点的个数：\\n&quot;); while (1) { scanf(&quot;%d&quot;, &amp;n); if (n&gt;1) break; else printf(&quot;输入错误，请重新输入n值！&quot;); } int* arr; arr = (int*)malloc(n*sizeof(ELEMTYPE)); printf(&quot;请输入%d个叶子结点的权值：\\n&quot;, n); for (i = 0; i&lt;n; ++i) { scanf(&quot;%d&quot;, &amp;arr[i]); } char ch[500], string[500]; printf(&quot;请连续输入这%d个叶子结点各自所代表的字符：\\n&quot;, n); fflush(stdin); // 强行清除缓存中的数据，也就是上面输入权值结束时的回车符 gets(string); HuffmanNode* hufmTree = NULL; hufmTree = createHuffmanTree(arr, n); printf(&quot;此哈夫曼树的广义表形式为：\\n&quot;); PrintHuffmanTree(hufmTree); printf(&quot;\\n各叶子结点的哈夫曼编码为：\\n&quot;); HuffmanCode(hufmTree, 0); printf(&quot;要解码吗？请输入编码:\\n&quot;); gets(ch); printf(&quot;解码结果为：\\n&quot;); HuffmanDecode(ch, hufmTree, string); printf(&quot;\\n&quot;); free(arr); free(hufmTree); return 0; } 结果 ：这里结果只用改一下就好 f}alg55fd5f50f0ddd0d00adafdd5505d50a5{ flag{ddf5dfd0f05550500a5af55dd0d5d0ad}","categories":[],"tags":[]},{"title":"php学习笔记（一）","slug":"php学习笔记（一）","date":"2019-04-07T14:01:19.275Z","updated":"2019-09-25T10:27:20.672Z","comments":true,"path":"2019/04/07/php学习笔记（一）/","link":"","permalink":"http://yxld.github.io/2019/04/07/php学习笔记（一）/","excerpt":"","text":"一.初识php1.php是什么php（全称：Hypertext Preprocessor，即“PHP：超文本预处理器”）是一种开源的服务端脚本语言。php独特的语法混合了C、Java、以及PHP自创的语法。它可以更快的执行动态网页。php是将程序嵌入到HTML文档中去执行。 2.php能做什么php 可以生成动态页面内容php 可以收集表单数据php 可以进行文字和图像处理php 可以添加、删除、修改您的数据库中的数据php 可以创建、打开、读取、写入、关闭服务器上的文件php 可以限制用户访问您的网站上的一些页面 3.为什么使用phpphp 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）， 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS、nginx 等），提供了广泛的数据库支持(mysql、oracle、db等)，php是开源免费的，官网：http://www.php.net/，php易于学习，并可高效地运行在服务器端。 二.php基本语法1.初识php脚本程序(1)开始结束php脚本以 &lt;?php 开始，以 ?&gt; 结束。 (2)php注释 单行注释//注释内容 多行注释/*注释内容*/ 2.变量（1）变量声明与赋值$变量名称; $变量名称 = 值; （2）变量名命名规则php变量必须以美元符号($)为前缀，变量名称必须以字母或下划线开头，包含字母、数字及下划线，变量名称禁止包含空格、斜线、反斜线等特殊符号，变量名称必须含义明确，不能使用关键字，变量名称建议遵守“小驼峰命名法”，php是一种“弱”类型语言，所以变量不需要声明数据类型变量名区分大小写 （3）变量输出echo():echo() 函数输出一个或多个字符串，多个值之间用逗号分隔。echo() 函数实际不是一个函数，所以不必对它使用括号。然而，如果希望向 echo() 传递一个以上的参数，使用括号将会生成解析错误。 print():print() 函数输出一个字符串，print() 函数实际不是一个函数，所以不必对它使用括号 （4）数据类型 字符串型字符型(String),必须括在定界符内，多个字符串用 . 连接 php字符数据类型的定界符有：单引号 &#39; &#39;双引号 &quot; &quot; 转义字符 整型整型(Integer),可以存储八进制、十进制、十六进制的整数 $a = 1234; // 十进制数 $a = -1; // 负数 $a = 0123; // 八进制数 (等于十进制 83) $a = 0x1A; // 十六进制数 (等于十进制 26) 整型数的字长和平台有关，通常是4个字节（-2147483648~2147483647） （5）转换临时转换转换成整型 –&gt; (int)、(integer)转换成浮点型 –&gt; (float)、(real)、(double)转换成布尔型 –&gt; (bool)、(boolean)转换成字符型 –&gt; (string)转换成数组 –&gt; (array)转换成对象 –&gt; (object)转换成空值 –&gt; unset $a=100; $b=200; (boolean)$a+$b=?//201 永久转换通过系统函数settype()设置变量的数据类型,语法:bool settype(mixed $var,string $type) $a=“1234b5”; echo (int)$a; //临时转换为1234， echo $a;//临时转换为1234，但是a的值还是不变的，输出1234b5 settype($a, int);//永久转换为1234 echo $a;//永久转换为1234，输出1234 unset() 销毁指定的变量。 3.常量常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器 定义和使用define(&#39;常量名称&#39;,常量值) 或者 define(&quot;常量名称&quot;,常量值) 常量的命名和变量一样 只能包含字母数字下划线 并且必须以 字母或者下划线开头，按照惯例常量名字总是大写的，自定义的常量是严格区分大小写的。 4.运算符1、算术运算符 +、-、*、/、% 2、赋值运算符 =、+=、-=、*=、/=、%=、.= 3、比较运算符 &gt;、&lt;、==、！=、&lt;=、&gt;=、===、！== 三.流程控制1.顺序执行顺序控制：在程序流程控制中，最基本的就是顺序控制。程序会按照自上而下的顺序执行。 2.分支执行单分支条件控制语句if(条件表达式){ 语句组; //语句组为单条语句时可省略“{ }”。 } 当条件表达式的值为真（true）时，php将执行语句组，相反条件表达式的值为假（false）时，php将不执行语句组，忽略语句组执行下面的语句。 双分支条件控制语句if(条件表达式){ 语句组1 }else{ 语句组2 } if-else 条件判断与 if 条件判断类似，所不同的是，if-else 语句的条件表达式值为真(true)时，会执行 if 的本体语句(语句组1)，而条件表达式值为假(false)时，则执行 else 的本体语句(语句组2)。 多分支条件控制语句if(条件表达式1){ 语句块1 }elseif(条件表达式1){ 语句块2 ... ... }elseif(条件表达式n){ 语句块n }else{ 语句块n+1 } swich语句switch (变量或表达式){ case 值1: 语句块1; break; case 值2: 语句块2; break; ... default: 代码段; } if语句嵌套if(表达式1){ if(表达式2){ .. .. .. }else{ .. .. .. } }else{ if(表达式3){ … } } if语句的嵌套，即指if或else后面的语句块中又包含if语句。if语句可以无限层地嵌套在其他if语句，这给程序的不同部分的条件执行提供了充分的弹性。 3.循环执行while语句while (条件表达式) { 循环体 } do……while语句do { 代码段 } while (条件表达式) for循环for (循环变量初始化表达式; 循环条件表达式; 更新循环变量表达式) { 循环体 } 4.特殊的流程控制语句continue语句continue语句只能应用在while、do……while、for和switch语句中，continue语句用于中止本次循环。 break语句break语句通常应用在while、do……while、for和switch语句中，break语句用于退出循环或者退出一个switch语句。 exit语句和die语句当前的脚本中只要执行到exit语句，而不管它在哪个控制流程中都会直接退出当前脚本。","categories":[],"tags":[]},{"title":"常见的加密与解密","slug":"常见的加密与解密","date":"2019-03-31T12:41:28.830Z","updated":"2019-04-28T08:36:04.870Z","comments":true,"path":"2019/03/31/常见的加密与解密/","link":"","permalink":"http://yxld.github.io/2019/03/31/常见的加密与解密/","excerpt":"","text":"加密与解密一.Base编码系列1.Base16Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码。注: Base16不可能用到填充符号“=”。 2.Base32Base32编码是使用32个可打印字符（字母A-Z和数字2-7）对任意字节数据进行编码的方案，编码后的字符串不用区分大小写并排除了容易混淆的字符，可以方便地由人类使用并由计算机处理。 3.Base64Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成ASCII字符串，另有“=”符号用作后缀用途。 二.凯撒密码1.简介在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。 2.加密、解密方法恺撒密码的加密、解密方法还能够通过同余的数学方法进行计算。首先将字母用数字代替，A=0，B=1，…，Z=25。此时偏移量为n的加密方法即为： 解密就是：（1）恺撒密码的替换方法是通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如：当偏移量是左移3的时候（解密时的密钥就是3）：明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ ；密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC。（2）使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG ；密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ。 三.URL编码1.简介url编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值 ，将它们以name/value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。 2.编码规则URL编码遵循下列规则： 每对name/value由&amp;；符分开；每对来自表单的name/value由=符分开。如果用户没有输入值给这个name，那么这个name还是出现，只是无值。任何特殊的字符（就是那些不是简单的七位ASCII，如汉字）将以百分符%用十六进制编码，当然也包括象 =,&amp;；，和 % 这些特殊的字符。其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。例如：“\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。那么汉字的url编码呢？很简单，看例子：“胡”的ascii码是-17670，十六进制是BAFA，url编码是“%BA%FA”。 四.摩尔斯电码1.简介摩尔斯电码（又译为摩斯密码，Morse code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。它发明于1837年，发明者有争议，是美国人塞缪尔·莫尔斯或者艾尔菲德·维尔。 摩尔斯电码是一种早期的数字化通信形式，但是它不同于现代只使用零和一两种状态的二进制代码，它的代码包括五种： 点、划、点和划之间的停顿、每个字符之间短的停顿、每个词之间中等的停顿以及句子之间长的停顿。 2.摩尔斯电码表例如：国际摩尔斯电码救难信号SOS是国际通用求救信号，这三个字母并非任何单词缩写，只是因为它的电码“ …—…”（三点，三长，三点）是电报中最容易发出和辨识的电码。","categories":[],"tags":[]},{"title":"css学习笔记","slug":"css学习笔记","date":"2019-03-30T15:36:35.125Z","updated":"2019-03-30T15:47:43.112Z","comments":true,"path":"2019/03/30/css学习笔记/","link":"","permalink":"http://yxld.github.io/2019/03/30/css学习笔记/","excerpt":"","text":"css一.简介层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。 二.四种引入 CSS 的方式：1.直接在标签里面定义style的属性（也叫内联样式）,这样的标签很长，不利于维护如： &lt;body style=&quot;background-color: red;&quot;&gt; &lt;h1 style=&quot;text-align: center;clolr: red;&quot;&gt;xxx&lt;/h1&gt; 2.style 标签 一般写在head里面（也可以写在其他地方）如： &lt;style&gt; body{ background-color: red; } &lt;/style&gt; 3.外部文件css link标签引入的方法 用link标签的方式引入一个stylesheet，新建一个.css的文档用link标签进行链接，为外部样式如： &lt;link rel=&quot;stylesheet&quot; href=./a.css&gt; 注：这个link与当前文档关系为stylesheet， 4.css import 在css里面引入另一个css如：在执行body前先执行b.css文件 @ import URL（./.b.css） 注：（）里面可以是相对路径也可以是绝对路径 body{ background-color: red; } 三.css选择器1.元素选择器使用时这个元素都会被修饰 2.Id选择器唯一单独的使用属性 3.Class选择器处理多个标签的使用如： &lt;!DO&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css选择器&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*派生选择器 通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁*/ li strong { font-style: italic; font-weight: normal; color: red; } /*id选择器。id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。id 选择器以 &quot;#&quot; 来定义。*/ #red{ color: red; } #orange{ color: orange; } /*类选择器 。在 CSS 中，类选择器以一个点号显示*/ .center{ text-align: center; color: blue; } /*属性选择器。对带有指定属性的 HTML元素设置样式。*/ [title]{ color: aqua; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;strong&gt;我是斜体字&lt;/strong&gt;&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;我会变成粗体字，原本我是斜体字&lt;/strong&gt;&lt;/li&gt; &lt;/ol&gt; &lt;h1 id=&quot;red&quot;&gt;我是id选择器&lt;/h1&gt; &lt;h2 id=&quot;orange&quot;&gt;我也是id选择器&lt;/h2&gt; &lt;h3 class=&quot;center&quot;&gt;我是类选择器&lt;/h3&gt; &lt;h5 title=&quot;&quot;&gt;我是属性选择器&lt;/h5&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[]},{"title":"html学习笔记","slug":"html学习笔记","date":"2019-03-27T12:28:36.140Z","updated":"2019-03-27T12:34:37.186Z","comments":true,"path":"2019/03/27/html学习笔记/","link":"","permalink":"http://yxld.github.io/2019/03/27/html学习笔记/","excerpt":"","text":"html了解htmlhtml承载的是一个网页上最原始的元素，包括文字、图片、视频等。但是有了这些内容是不够的，它还要以一定的形式呈现出来，才能吸引到人。这就要用到css了，通过css可以改变这些元素呈现的样式，包括字体、颜色、背景、边框等，让原本枯燥的内容看起来更加美观。到此为止，仍然是静态的呈现，如果要让页面更加生动，就需要给页面添加动画和交互，让人可以和你的页面“互动”，javascript可以很好的做到这一点。 用人来比喻，就再恰当不过了，html就像人身上的各个部分，头，手，脚，身体，有了这些，你就是一个人了，接着你需要穿上各种衣服（css），包装好自己，再走出家门去接触社会，但一个静止不动、木讷的人，是很难受欢迎的，你需要会走会跳，别人和你说话交流你要会回应（js）。 1.html的基本结构123456789&lt;!DOCTYPE HTML&gt; &lt;!-- 标准网页声明，为固定格式，置于所有代码最前面 --&gt;&lt;html&gt; &lt;!-- 根标签，为固定格式 --&gt; &lt;head&gt; &lt;!--定义文档的头部，为固定格式--&gt; …… &lt;/head&gt; &lt;!--head对应的结束标签，为固定格式 --&gt; &lt;body&gt; &lt;!--定义网页的主要内容，如文字，图片，视频等 --&gt; …… &lt;/body&gt; &lt;!--body对应的结束标签，为固定格式 --&gt;&lt;/html&gt; &lt;!--html对应的结束标签，为固定格式 --&gt; 注意所有结束标签均比开始标签多一个“/”。 2. 注释：&lt;!-- …… --&gt;不管是用什么语言编程，注释都是最重要的，一定要养成写注释的好习惯，关键的注释不仅可以让别人一眼望去明白你写的代码的架构，更可以让自己有清晰的思路组织代码，某一日回过头来看也可以快速看懂。 3．head部分相关的标签（一）标题标题标签：&lt;title&gt; …… &lt;/title&gt;打开浏览器页面时，我们会看到浏览器边框上有一些网页名称，每一个网页的标签，都是不一样的，并且是这个网页最具有代表性的关键内容； （2）样式标签：&lt;style&gt; …… &lt;/style&gt;用于修改网页内容的呈现方式，如文字的颜色，大小，表格样式等。 4．body部分标签（1）标题标签：&lt;hx&gt; …… &lt;/hx&gt;标题标签用来显示网页一段内容的标题，x代表的数字范围是1～6，h1的优先级最高，显示的字体也最大，x的数字越大，优先级越低，字体也越小， “h”代表的是英文head。 （2）段落标签：&lt;p&gt; …… &lt;/p &gt;用来放常规的文字内容，一段对应一个p标签，默认每个段落后面空一行。”p”代表英文paragraph的缩写。 （3）强调文本–斜体：&lt;em&gt; …… &lt;/em&gt;使用该标签，可以将标签内的文字变成斜体，”em”指的是emphasis。 （4）强调文本–加粗：&lt;strong&gt;……&lt;/strong&gt;使用该标签，可以将标签内的文字加粗。 （5）短文本引用标签：&lt;q&gt;……&lt;/q&gt;有的时候，我们在网页的文字内容中需要加入一些引用的语句，如较短的名人名言，古诗词等等，可以用到短文本标签，它可以为标签内的引用语句自动加入双引号。但使用该标签的目的不是为了免去手工输入双引号的麻烦（实际上加入代码并不会减少麻烦），而是为了强调这部分文字是引用的。”q”指的是quote。 （6）长文本引用标签：&lt;blockquote&gt;……&lt;/blockquote&gt;只引用一、两句话的短文本时，可以使用短文本标签，但如果要成段的引用别人的文本时，显然就不适合了。我们在阅读书籍时，也会发现，当书里的作者成段的引用别人的文本时，会将其单独拿出来作为一段，并且格式也会和正文有所不用。blockquote就可以实现这样的功能，默认的样式是添加缩进样式。 （7）换行标签：&lt;br&gt;在html中，换行（即回车符号）及空格是无法被识别的，若需要换行，则要添加br标签，注意它只有开始标签而没有结束标签。”br”指的是barter rabbet。 （8）空格标签：&amp;nbsp；在html中，需空格时可使用该标签，”nbsp”指的是no-breaking space，前面的”&amp;”和后面的”;”是固定格式。 （9）分割线标签：&lt;hr&gt;使用该标签可在网页中添加分割线，”hr”指的是horizontal ruler。 （10）地址标签：&lt;address&gt;……&lt;/address&gt;在很多网页中，我们都会看到一些联系地址，这时候就要用到地址标签。使用地址标签可以为文本添加斜体及换行样式。所有的这些属性标签，并不是为了改变文本的样式，而是为了赋予给它相应的属性。 （11）代码标签：&lt;code&gt;……&lt;/code&gt;在网页中，有时会需要呈现代码，少量代码可使用code标签，代码多的话可使用下面的pre标签。 （12）预格式化文本标签：&lt;pre&gt;……&lt;/pre&gt;pre标签中的内容会毫无变动的呈现出来，包括保留文本中原有的空格、换行等，可用于呈现多行代码。”pre”指的是predefined。 （13）列表标签（无序）：&lt;ul&gt; &lt;li&gt; …… &lt;/li&gt; &lt;/ul&gt; 有时，我们有一系列处于同等地位的内容要呈现出来，但又不希望添加数字序列，就可以使用无序列表标签，该标签会使每个li标签内的内容前面都带一个圆点。”ul”指unorder list，”li”指list item。 （14）列表标签（有序）&lt;ol&gt; &lt;li&gt; …… &lt;/li&gt; &lt;/ol&gt; 如需要让列表内容有序排列，则可使用有序列表标签，它会对每个li标签的内容从1开始自增的添加序列。”ol”指的是order list。 （15）表格标签：&lt;table&gt;……&lt;/table&gt;表格是文本呈现较为直观的一种方式，默认的表格样式是不显示边框的，可通过css改变样式。表格分为摘要、标题、行、表头、列。 1）表格摘要：&lt;table summary=&quot; ……&quot;&gt;表格摘要的内容不会显示在浏览器中，添加是为了让自己知道该表格的大致内容。 2）表格标题：&lt;caption&gt;……&lt;/caption&gt;标题内容居中置于表格上方。 3）行：&lt;tr&gt;……&lt;/tr&gt;表格的行，表格中有几个tr标签，就有几行。”tr”指table row。 4）表头：&lt;th&gt;……&lt;/th&gt;表格的第一行称为表头，置于第一个tr标签中，一般加粗显示。”td”指table head。 5）列：&lt;td&gt;……&lt;/td&gt;表格每一行的元素个数（我更喜欢称它为列），嵌套于tr标签中，有几个td标签就有 几列。”td”指table data cell。 （16）链接标签：&lt; a href=&quot; &quot; title=&quot;鼠标飘过时显示的内容&quot; target=&quot;页面以什么形式打开&quot;&gt;……&lt;/ a&gt;实现给某段文字添加链接的功能，”href”指Hypertext Refrence。 （17）图片标签：&lt; img src=&quot;图片url地址&quot; alt=&quot;下载失败时显示的文本&quot;&gt;在网页中插入图片元素，”src”指standard requirment code。 （18）层次标签：&lt;div id=&quot;标识名称&quot;&gt;……&lt;/div&gt;将网页中要呈现的内容分好层次，id标识的内容不会在网页中呈现，是为了让自己更快知道div里面的大致内容而设的。”div”指division，”id”指identification。 （19）表单标签：&lt;form&gt;……&lt;/form&gt;表单是一个包含表单元素的区域。 5.总结学习的感悟就是英文真的非常重要，如果单纯的只记得符号和它对应的功能的话，太繁杂了，还是要了解相应的英文及意思，记起来会快很多也牢固很多，因此我在每一个标签后都写了对应的英文","categories":[],"tags":[]},{"title":"Hello Hexo","slug":"hello-world","date":"2019-03-15T08:12:57.087Z","updated":"2019-03-29T09:57:20.659Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"http://yxld.github.io/2019/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello hexoQuick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}